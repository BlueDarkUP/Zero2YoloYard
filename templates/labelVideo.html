{% extends "layout.html" %}

{% block head %}
<style>
    #canvas-container {
        position: relative;
        cursor: crosshair;
        max-width: 100%;
        display: inline-block;
    }

    #canvas-container.sam-active,
    #canvas-container.lam-active {
        cursor: copy;
    }

    #canvas-container.sam-loading {
        cursor: wait;
    }

    #canvas-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }

    #drawing-canvas {
        pointer-events: auto;
        z-index: 10;
    }

    #crosshair-canvas {
        z-index: 5;
    }

    #frame-image {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        border-radius: 0.25rem;
    }

    #class-list .list-group-item,
    #bbox-list .list-group-item {
        cursor: pointer;
    }

    #bbox-list .list-group-item.selected {
        border-color: #007bff;
        border-width: 2px;
        background-color: #e7f3ff;
    }

    #class-list .list-group-item.active {
        color: white;
        border-width: 2px;
    }

    #sam-toggle-btn.active,
    #interactive-mode-toggle.active,
    #lam-toggle-btn.active {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
    }

    .color-swatch {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin-right: 10px;
        border: 1px solid #ccc;
        vertical-align: middle;
        border-radius: 3px;
    }

    .side-panel {
        max-height: 85vh;
        overflow-y: auto;
    }

    #toast-notification {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        border-radius: 5px;
        background-color: #333;
        color: white;
        font-weight: bold;
        z-index: 9999;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }

    #toast-notification.show {
        opacity: 1;
        visibility: visible;
    }

    #interpolation-banner {
        display: none;
        padding: 0.75rem 1.25rem;
        margin-bottom: 1rem;
        border: 1px solid transparent;
        border-radius: 0.25rem;
        background-color: #d1ecf1;
        border-color: #bee5eb;
        color: #0c5460;
        font-weight: bold;
        text-align: center;
    }

    #track-controls {
        display: none;
        border: 2px dashed #007bff;
        padding: 15px;
        margin-top: 15px;
        background-color: #f8f9fa;
        border-radius: 0.3rem;
    }

    #interactive-segment-controls {
        display: none;
        border: 2px dashed #17a2b8;
        padding: 15px;
        margin-top: 15px;
        background-color: #f8f9fa;
        border-radius: 0.3rem;
    }

    .shortcut-keys-container {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-top: 0.5rem;
    }

    .shortcut-key {
        background-color: #e9ecef;
        border: 1px solid #dee2e6;
        padding: 0.2rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: bold;
        color: #495057;
    }

    .adv-settings-label {
        font-size: 0.8rem;
        font-weight: bold;
        margin-bottom: 0.2rem;
    }

    #drawing-canvas.cursor-move { cursor: move; }
    #drawing-canvas.cursor-nwse-resize { cursor: nwse-resize; }
    #drawing-canvas.cursor-nesw-resize { cursor: nesw-resize; }
    #drawing-canvas.cursor-ns-resize { cursor: ns-resize; }
    #drawing-canvas.cursor-ew-resize { cursor: ew-resize; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid slide-in-up">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <h3 class="mb-0">
                <span class="text-muted">Task for {{ task_entity.assigned_to }}:</span> {{ video_entity.description }}
            </h3>
            <p class="lead mb-0">(Frames {{ task_entity.start_frame }} to {{ task_entity.end_frame }})</p>
        </div>
        <a href="/" class="btn btn-secondary"><i class="bi bi-arrow-left-circle"></i> Back to Home</a>
    </div>

    <div class="row">
        <div class="col-lg-8 col-xl-9">
            <div id="interpolation-banner">
                <i class="bi bi-bezier"></i> **INTERPOLATION MODE ACTIVE**: Go to target frame, adjust the box, and click 'Confirm'. Press 'Esc' to cancel.
            </div>
            <div class="canvas-area">
                <div id="canvas-container">
                    <img id="frame-image" src="{{ first_frame_url }}" class="img-fluid" alt="Video Frame" draggable="false" />
                    <canvas id="crosshair-canvas"></canvas>
                    <canvas id="drawing-canvas"></canvas>
                </div>
                <div class="mt-3">
                    <label for="frame-slider">
                        Frame: <span id="frame-number-display" class="font-weight-bold">{{ task_entity.start_frame }}</span> / {{ task_entity.end_frame }}
                    </label>
                    <input type="range" class="form-control-range" id="frame-slider" min="{{ task_entity.start_frame }}" max="{{ task_entity.end_frame }}" value="{{ task_entity.start_frame }}">
                    <div class="shortcut-keys-container">
                        <span class="shortcut-key">S</span> Save/Update
                        <span class="shortcut-key">A</span> Prev
                        <span class="shortcut-key">D</span> Next
                        <span class="shortcut-key">C</span> Cycle Boxes
                        <span class="shortcut-key">Esc</span> Cancel Interpolation
                        <span class="shortcut-key">Ctrl+Z</span> Undo
                        <span class="shortcut-key">Ctrl+Y</span> Redo
                        <span class="shortcut-key">Del</span> Delete
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-4 col-xl-3">
            <div class="side-panel">
                <div class="d-flex justify-content-between align-items-center">
                    <h4><i class="bi bi-tags"></i> Classes</h4>
                    <div>
                        <button id="find-from-dataset-btn" class="btn btn-sm btn-outline-info" title="Find objects of the selected class using all examples from the entire dataset."><i class="bi bi-journal-album"></i> Find from Dataset</button>
                        <button id="rebuild-prototypes-btn" class="btn btn-sm btn-outline-warning ml-2" title="Re-calculate AI models for all classes from all saved labels. This is a background task.">
                            <i class="bi bi-arrow-clockwise"></i> Rebuild AI Models
                        </button>
                    </div>
                </div>
                <div class="input-group my-3">
                    <input type="text" id="new-class-name" class="form-control" placeholder="New class name">
                    <div class="input-group-append">
                        <button id="add-class-btn" class="btn btn-outline-secondary" type="button">Add</button>
                    </div>
                </div>
                <ul id="class-list" class="list-group mb-3"></ul>

                <hr>

                <h4><i class="bi bi-bounding-box"></i> Bounding Boxes</h4>
                <p><small class="text-muted">Select a class to draw, or use an AI tool below.</small></p>
                <button id="save-bboxes" class="btn btn-primary btn-block mb-2"><i class="bi bi-save"></i> Save BBoxes (S)</button>
                <button id="lam-toggle-btn" class="btn btn-info btn-block mb-2"><i class="bi bi-bullseye"></i> Enable LAM (Click to Label)</button>
                <button id="sam-toggle-btn" class="btn btn-info btn-block mb-2"><i class="bi bi-magic"></i> Enable SAM (Point)</button>
                <button id="interactive-mode-toggle" class="btn btn-info btn-block mb-2"><i class="bi bi-stars"></i> Enable Smart Select</button>
                <button id="sam2-track-btn" class="btn btn-success btn-block mb-3"><i class="bi bi-play-circle"></i> Track Objects with SAM2</button>

                <div id="interactive-segment-controls">
                    <h5 class="mb-3"><i class="bi bi-stars"></i> Smart Select Tool</h5>
                    <p><small class="text-muted">Draw a box around one object. Similar objects will be found automatically.</small></p>
                    <button id="find-similar-btn" class="btn btn-primary btn-block" style="display: none;"><i class="bi bi-search"></i> Find Similar Objects</button>
                    <button id="clear-samples-btn" class="btn btn-secondary btn-block mt-1"><i class="bi bi-eraser"></i> Clear Sample & Previews</button>
                    <hr>
                    <div id="interactive-results-controls" style="display: none;" class="mt-2">
                        <h5>Review & Assign</h5>
                        <p><small class="text-muted">Select a class, then click on a blue box to assign it. Hold <strong>C</strong> to cycle through overlapping boxes.</small></p>
                        <div class="form-group">
                            <label for="result-threshold">Confidence Threshold: <strong id="threshold-value">0.50</strong></label>
                            <input type="range" class="form-control-range" id="result-threshold" min="0.1" max="0.99" step="0.01" value="0.50">
                        </div>
                        <button id="accept-visible-btn" class="btn btn-success btn-block mt-2"><i class="bi bi-check2-all"></i> Accept All Visible</button>
                        <button id="finish-interactive-btn" class="btn btn-secondary btn-block mt-1"><i class="bi bi-x-circle"></i> Finish & Clear Previews</button>
                    </div>
                </div>

                <div id="track-controls">
                    <h5 id="track-status-header">Tracking...</h5>
                    <div class="progress mb-2" style="height: 20px;">
                        <div id="track-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;">0%</div>
                    </div>
                    <button id="stop-sam2-track-btn" class="btn btn-danger btn-block"><i class="bi bi-stop-circle"></i> Stop Tracking</button>
                    <hr>
                    <h5>Review Mode</h5>
                    <p><small class="text-muted">Use A/D to review. Correct boxes. Press (S) to update a frame in cache.</small></p>
                    <button id="save-all-tracked-btn" class="btn btn-warning btn-block" disabled><i class="bi bi-check2-all"></i> Save All Reviewed Frames</button>
                    <button id="exit-track-mode-btn" class="btn btn-secondary btn-block mt-2"><i class="bi bi-x-circle"></i> Exit & Discard</button>
                </div>

                <ul id="bbox-list" class="list-group mt-3"></ul>
            </div>
        </div>
    </div>
</div>

<div id="toast-notification"></div>

<template id="bbox-item-template">
    <li class="list-group-item d-flex justify-content-between align-items-center">
        <div>
            <span class="color-swatch"></span>
            <span class="bbox-label font-weight-bold"></span>
            <small class="bbox-id text-muted ml-2"></small>
        </div>
        <div>
            <button class="btn btn-info btn-sm interpolate-btn" title="Start keyframe interpolation for this object">
                <i class="bi bi-bezier"></i>
            </button>
            <button class="btn btn-danger btn-sm delete-bbox-btn">&times;</button>
        </div>
    </li>
</template>

<template id="lam-suggestion-popup-template">
    <div id="lam-suggestion-popup" style="position: absolute; z-index: 1000; width: 180px;">
        <div class="list-group shadow-sm">
        </div>
    </div>
</template>

<div class="modal fade" id="tracking-options-modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select Tracking Mode</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Choose the best tracking method for your task.</p>
                <div class="list-group">
                    <label class="list-group-item list-group-item-action">
                        <div class="d-flex w-100 justify-content-between">
                            <h6 class="mb-1"><input type="radio" name="tracking-mode" value="interactive" checked> Interactive Tracking</h6>
                            <small><span class="badge badge-primary">Recommended</span></small>
                        </div>
                        <p class="mb-1 small text-muted">Real-time feedback, can be stopped and corrected at any time. Ideal for complex scenes or when accuracy needs supervision.</p>
                    </label>
                    <label class="list-group-item list-group-item-action">
                        <div class="d-flex w-100 justify-content-between">
                            <h6 class="mb-1"><input type="radio" name="tracking-mode" value="batch"> High-Accuracy Batch Mode</h6>
                             <small><span class="badge badge-success">High Quality</span></small>
                        </div>
                        <p class="mb-1 small text-muted">Uses the official `SAM2VideoPredictor` for potentially better results but cannot be stopped. Best for clear, stable video clips.</p>
                    </label>
                </div>

                <div id="batch-mode-options" class="mt-3" style="display: none;">
                    <div class="form-group">
                        <label for="batch-end-frame"><strong>Process until frame:</strong></label>
                        <input type="number" class="form-control" id="batch-end-frame" min="0">
                        <small class="form-text text-muted">The tracking will run from the current frame up to this frame.</small>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                <button type="button" id="confirm-tracking-start" class="btn btn-primary"><i class="bi bi-play-circle-fill"></i> Start Tracking</button>
            </div>
        </div>
    </div>
</div>

{% from "_macros.html" import render_modal %}
{% call render_modal('negative-sampling-modal', 'Step 2: Refine with Negative Samples (Optional)') %}
<div id="neg-sampling-body">
    <p class="text-info">Draw boxes around areas you want the model to **avoid** (e.g., background, other objects). These are temporary and only used for this task.</p>
    <div class="text-center mb-3">
        <div id="neg-canvas-container" style="position: relative; display: inline-block; max-width: 100%;">
            <img id="neg-frame-image" src="" class="img-fluid" alt="Negative Sample Frame" draggable="false" />
            <canvas id="neg-drawing-canvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
        </div>
    </div>
    <div class="d-flex justify-content-between align-items-center mt-3">
        <button id="neg-prev-btn" class="btn btn-secondary"><i class="bi bi-arrow-left"></i> Previous</button>
        <strong id="neg-frame-counter">Frame 1 / 10</strong>
        <button id="neg-next-btn" class="btn btn-secondary">Next <i class="bi bi-arrow-right"></i></button>
    </div>
    <p class="text-muted small mt-2">Use Ctrl+Z to undo the last box on the current frame, and Delete to clear all boxes on this frame.</p>
</div>
<div class="modal-footer">
    <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
    <button type="button" id="finish-neg-sampling-btn" class="btn btn-primary"><i class="bi bi-check2-circle"></i> Finish & Apply to Video</button>
</div>
{% endcall %}

{% endblock %}

{% block scripts %}
<script>
    $(document).ready(function() {
        const videoUuid = "{{ video_entity.video_uuid }}";
        const task = {{ task_entity | tojson }};
        const frameCount = task.end_frame + 1;

        let availableClasses = [];
        let activeClass = null;
        let bboxes = [];
        let selectedBboxIndex = -1;

        let history = [];
        let historyIndex = -1;

        let isDrawing = false;
        let startX, startY;

        let isSamModeActive = false;
        let isLamModeActive = false;
        let sam2TrackerUuid = null;
        let sam2EventSource = null;
        let isReviewMode = false;
        let trackedBboxCache = {};

        let isInteractiveMode = false;
        let positiveExampleBboxes = [];
        let previewBboxes = [];
        let currentCacheKey = null;
        let lastProcessedFrame = -1;
        let lastDatasetClassName = null;
        let hoveredPreviewIndex = -1;
        let overlappingCycleIndex = 0;
        let lastClickPosForCycle = null;
        let isCKeyPressed = false;
        
        // <!-- FIX [问题二] START -->
        // 用于存储每一帧的置信度设置
        let frameConfidence = {}; 
        // <!-- FIX [问题二] END -->

        let interpolationState = {
            isActive: false,
            objectId: null,
            startFrameData: null
        };

        let editMode = null;
        let draggedHandle = null;
        let draggedBboxInitialState = null;
        let isDraggingBbox = false;

        let negSamplingFrames = [];
        let currentNegSampleIndex = 0;
        let negativeSamplesStore = {};
        let isDrawingNeg = false;
        let negStartX, negStartY;

        let toastTimeout;

        const canvasContainer = $('#canvas-container');
        const drawingCanvas = document.getElementById('drawing-canvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const crosshairCanvas = document.getElementById('crosshair-canvas');
        const crosshairCtx = crosshairCanvas.getContext('2d');
        const frameImage = document.getElementById('frame-image');
        const frameSlider = $('#frame-slider');
        const negCanvas = document.getElementById('neg-drawing-canvas');
        const negCtx = negCanvas.getContext('2d');
        const negImage = document.getElementById('neg-frame-image');

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = frameImage.getBoundingClientRect();
            [drawingCanvas, crosshairCanvas].forEach(canvas => {
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                canvas.width = Math.round(rect.width * dpr);
                canvas.height = Math.round(rect.height * dpr);
            });
            drawingCtx.scale(dpr, dpr);
            crosshairCtx.scale(dpr, dpr);
            redrawCanvas();
        }

        function redrawCanvas() {
            if (!frameImage.complete || frameImage.naturalWidth === 0) return;

            const dpr = window.devicePixelRatio || 1;
            drawingCtx.clearRect(0, 0, drawingCanvas.width / dpr, drawingCanvas.height / dpr);
            const scaleX = frameImage.clientWidth / frameImage.naturalWidth;
            const scaleY = frameImage.clientHeight / frameImage.naturalHeight;

            if (interpolationState.isActive) {
                const startBox = interpolationState.startFrameData.bbox;
                const x = startBox.x1 * scaleX,
                    y = startBox.y1 * scaleY,
                    w = (startBox.x2 - startBox.x1) * scaleX,
                    h = (startBox.y2 - startBox.y1) * scaleY;
                drawingCtx.strokeStyle = 'rgba(255, 193, 7, 0.5)';
                drawingCtx.lineWidth = 2 / dpr;
                drawingCtx.setLineDash([4 / dpr, 4 / dpr]);
                drawingCtx.strokeRect(x, y, w, h);
                drawingCtx.setLineDash([]);
            }

            bboxes.forEach((box, index) => {
                const color = stringToColor(box.label);
                drawingCtx.strokeStyle = color;
                drawingCtx.lineWidth = (index === selectedBboxIndex) ? 4 / dpr : 2 / dpr;
                drawingCtx.shadowColor = (index === selectedBboxIndex) ? 'black' : 'transparent';
                drawingCtx.shadowBlur = (index === selectedBboxIndex) ? 6 / dpr : 0;

                if (interpolationState.isActive && box.id === interpolationState.objectId) {
                    drawingCtx.strokeStyle = '#28a745';
                    drawingCtx.shadowColor = 'black';
                    drawingCtx.shadowBlur = 8 / dpr;
                    drawingCtx.setLineDash([5 / dpr, 3 / dpr]);
                }

                const x = box.x1 * scaleX,
                    y = box.y1 * scaleY,
                    w = (box.x2 - box.x1) * scaleX,
                    h = (box.y2 - box.y1) * scaleY;
                drawingCtx.strokeRect(x, y, w, h);
                drawingCtx.setLineDash([]);
                drawingCtx.shadowBlur = 0;

                drawingCtx.fillStyle = interpolationState.isActive && box.id === interpolationState.objectId ? '#28a745' : color;
                drawingCtx.font = `${12/dpr}px Arial`;
                const textMetrics = drawingCtx.measureText(box.label);
                const textWidth = textMetrics.width;
                const textHeight = 14 / dpr;
                drawingCtx.fillRect(x, y - textHeight, textWidth + (4 / dpr), textHeight);
                drawingCtx.fillStyle = 'white';
                drawingCtx.fillText(box.label, x + (2 / dpr), y - (2 / dpr));

                if (index === selectedBboxIndex && !isInteractiveMode) {
                    const handleSize = 8 / dpr;
                    const halfHandle = handleSize / 2;
                    const handles = {
                        'top-left': { x: x, y: y },
                        'top-middle': { x: x + w / 2, y: y },
                        'top-right': { x: x + w, y: y },
                        'middle-left': { x: x, y: y + h / 2 },
                        'middle-right': { x: x + w, y: y + h / 2 },
                        'bottom-left': { x: x, y: y + h },
                        'bottom-middle': { x: x + w / 2, y: y + h },
                        'bottom-right': { x: x + w, y: y + h }
                    };
                    drawingCtx.fillStyle = '#007bff';
                    for (const key in handles) {
                        const pos = handles[key];
                        drawingCtx.fillRect(pos.x - halfHandle, pos.y - halfHandle, handleSize, handleSize);
                    }
                }
            });

            if ((isInteractiveMode || previewBboxes.length > 0) && previewBboxes.length > 0) {
                const threshold = parseFloat($('#result-threshold').val());
                previewBboxes.forEach((res, index) => {
                    if (res.score >= threshold) {
                        const box = res.box;
                        if (index === hoveredPreviewIndex) {
                            drawingCtx.strokeStyle = 'rgba(255, 193, 7, 1.0)';
                            drawingCtx.lineWidth = 3 / dpr;
                        } else {
                            drawingCtx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
                            drawingCtx.lineWidth = 2 / dpr;
                        }
                        const x = box[0] * scaleX,
                            y = box[1] * scaleY,
                            w = (box[2] - box[0]) * scaleX,
                            h = (box[3] - box[1]) * scaleY;
                        drawingCtx.strokeRect(x, y, w, h);

                        const scoreText = res.score.toFixed(2);
                        drawingCtx.fillStyle = (index === hoveredPreviewIndex) ? 'rgba(255, 193, 7, 1.0)' : 'rgba(0, 123, 255, 0.8)';
                        drawingCtx.font = `${10/dpr}px Arial`;
                        drawingCtx.fillText(scoreText, x + 2 / dpr, y + 10 / dpr);
                    }
                });
            }

            if (isInteractiveMode) {
                positiveExampleBboxes.forEach(box => {
                    drawingCtx.strokeStyle = 'rgba(40, 167, 69, 0.9)';
                    drawingCtx.lineWidth = 2 / dpr;
                    drawingCtx.setLineDash([5 / dpr, 3 / dpr]);
                    const x = box.x1 * scaleX,
                        y = box.y1 * scaleY,
                        w = (box.x2 - box.x1) * scaleX,
                        h = (box.y2 - box.y1) * scaleY;
                    drawingCtx.strokeRect(x, y, w, h);
                    drawingCtx.setLineDash([]);
                });
            }
        }

        function renderBboxList() {
            const list = $("#bbox-list");
            list.empty();
            bboxes.forEach((box, index) => {
                const template = document.getElementById("bbox-item-template").content.cloneNode(true);
                const color = stringToColor(box.label);
                const listItem = $(template).find("li");

                listItem.attr("data-index", index);
                if (index === selectedBboxIndex) {
                    listItem.addClass("selected");
                }

                $(template).find(".color-swatch").css("background-color", color);
                $(template).find(".bbox-label").text(box.label);
                $(template).find(".bbox-id").text(box.id ? `ID: ${box.id.substring(0, 4)}` : 'No ID');
                $(template).find(".delete-bbox-btn").attr("data-index", index);

                const interpolateBtn = $(template).find(".interpolate-btn");
                if (interpolationState.isActive) {
                    if (interpolationState.objectId === box.id) {
                        interpolateBtn.removeClass('btn-info').addClass('btn-success')
                            .html('<i class="bi bi-check-circle"></i> Confirm')
                            .attr('title', `Confirm interpolation from frame ${interpolationState.startFrameData.frame_number}`)
                            .prop('disabled', false);
                    } else {
                        interpolateBtn.prop('disabled', true);
                    }
                }
                list.append(template);
            });
        }

        function renderClassList() {
            const list = $("#class-list");
            list.empty();
            availableClasses.forEach(className => {
                const color = stringToColor(className);
                const colorSwatch = `<span class="color-swatch" style="background-color: ${color};"></span>`;
                const listItem = $(`<li class="list-group-item">${colorSwatch}${className}</li>`);
                listItem.attr("data-class-name", className);
                if (className === activeClass) {
                    listItem.addClass("active").css({
                        "background-color": color,
                        "border-color": color
                    });
                }
                list.append(listItem);
            });
        }

        function drawCrosshairs(x, y) {
            if (isDrawing || isReviewMode || isDraggingBbox) return;
            const dpr = window.devicePixelRatio || 1;
            crosshairCtx.clearRect(0, 0, crosshairCanvas.width / dpr, crosshairCanvas.height / dpr);
            crosshairCtx.strokeStyle = "rgba(0,0,255,0.7)";
            crosshairCtx.lineWidth = 1 / dpr;
            crosshairCtx.setLineDash([4 / dpr, 4 / dpr]);
            crosshairCtx.beginPath();
            crosshairCtx.moveTo(0, y);
            crosshairCtx.lineTo(crosshairCanvas.width / dpr, y);
            crosshairCtx.stroke();
            crosshairCtx.beginPath();
            crosshairCtx.moveTo(x, 0);
            crosshairCtx.lineTo(x, crosshairCanvas.height / dpr);
            crosshairCtx.stroke();
        }

        function clearCrosshairs() {
            const dpr = window.devicePixelRatio || 1;
            crosshairCtx.clearRect(0, 0, crosshairCanvas.width / dpr, crosshairCanvas.height / dpr);
        }

        function showToast(message, duration = 3000) {
            const notification = $("#toast-notification");
            notification.text(message).addClass("show");
            if (toastTimeout) {
                clearTimeout(toastTimeout);
            }
            toastTimeout = setTimeout(() => {
                notification.removeClass("show");
            }, duration);
        }

        function saveStateToHistory() {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.parse(JSON.stringify(bboxes)));
            historyIndex = history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                bboxes = JSON.parse(JSON.stringify(history[historyIndex]));
                selectedBboxIndex = -1;
                redrawCanvas();
                renderBboxList();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                bboxes = JSON.parse(JSON.stringify(history[historyIndex]));
                selectedBboxIndex = -1;
                redrawCanvas();
                renderBboxList();
            }
        }

        function getMousePos(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        function getHandleAtPos(x, y) {
            if (selectedBboxIndex === -1) return null;
            const scaleX = frameImage.clientWidth / frameImage.naturalWidth;
            const scaleY = frameImage.clientHeight / frameImage.naturalHeight;
            const box = bboxes[selectedBboxIndex];
            const bx = box.x1 * scaleX,
                by = box.y1 * scaleY,
                bw = (box.x2 - box.x1) * scaleX,
                bh = (box.y2 - box.y1) * scaleY;
            const handleSize = 8;
            const handles = {
                'top-left': { x: bx, y: by },
                'top-middle': { x: bx + bw / 2, y: by },
                'top-right': { x: bx + bw, y: by },
                'middle-left': { x: bx, y: by + bh / 2 },
                'middle-right': { x: bx + bw, y: by + bh / 2 },
                'bottom-left': { x: bx, y: by + bh },
                'bottom-middle': { x: bx + bw / 2, y: by + bh },
                'bottom-right': { x: bx + bw, y: by + bh }
            };

            for (const key in handles) {
                const pos = handles[key];
                if (x >= pos.x - handleSize && x <= pos.x + handleSize && y >= pos.y - handleSize && y <= pos.y + handleSize) {
                    return key;
                }
            }
            return null;
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            return `hsl(${(hash % 360 + 360) % 360}, 80%, 50%)`;
        }

        function formatBboxesToString() {
            return bboxes
                .filter(b => b.x1 != null && b.y1 != null && b.x2 != null && b.y2 != null && !isNaN(b.x1) && !isNaN(b.y1) && !isNaN(b.x2) && !isNaN(b.y2))
                .map(b => {
                    const objectId = b.id || self.crypto.randomUUID();
                    b.id = objectId;
                    return `${b.x1},${b.y1},${b.x2},${b.y2},${b.label},${objectId}`;
                }).join("\n");
        }

        function parseBboxesFromString(text) {
            if (!text) return [];
            return text.split("\n")
                .filter(line => line.trim() !== "")
                .map(line => {
                    const parts = line.split(",");
                    if (parts.length < 5) return null;
                    const hasId = parts.length > 5 && (parts[parts.length - 1].length === 36 || parts[parts.length - 1].length === 32);
                    const label = parts.slice(4, parts.length - (hasId ? 1 : 0)).join(',');
                    const id = hasId ? parts[parts.length - 1] : null;
                    return {
                        x1: parseInt(parts[0]),
                        y1: parseInt(parts[1]),
                        x2: parseInt(parts[2]),
                        y2: parseInt(parts[3]),
                        label: label,
                        id: id
                    };
                }).filter(b => b !== null);
        }

        function loadBboxesForFrame(frameNumber) {
            if (isReviewMode) {
                const bboxesText = trackedBboxCache[frameNumber] || "";
                processFrameDataAndUpdateUI({
                    bboxes_text: bboxesText
                });
                return;
            }

            if (window.cachedFrames) {
                const frameData = window.cachedFrames.find(f => f.frame_number == frameNumber);
                processFrameDataAndUpdateUI(frameData);
            } else {
                $.ajax({
                    url: "/retrieveVideoFrames",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        video_uuid: videoUuid
                    }),
                    success: function(response) {
                        if (response.success) {
                            window.cachedFrames = response.frames;
                            const frameData = window.cachedFrames.find(f => f.frame_number == frameNumber);
                            processFrameDataAndUpdateUI(frameData);
                        }
                    }
                });
            }
        }

        // <!-- FIX [问题一] START -->
        // 重新设计此函数以避免智能选择面板在加载带有AI建议的帧时闪烁
        function processFrameDataAndUpdateUI(frameData) {
            const currentFrameNum = parseInt(frameSlider.val());
            const manualBboxes = parseBboxesFromString(frameData ? frameData.bboxes_text : '');
            const suggestedBboxesText = frameData ? frameData.suggested_bboxes_text : '';
            const suggestedBboxes = parseBboxesFromString(suggestedBboxesText);

            if (suggestedBboxes.length > 0) {
                // 如果有AI建议，我们直接加载它们，而不调用clearInteractiveSession，从而避免UI闪烁。
                bboxes = []; // 清空手动标注框
                previewBboxes = suggestedBboxes.map(b => ({
                    box: [b.x1, b.y1, b.x2, b.y2],
                    score: 0.99, // 为AI预标注建议设置一个高置信度
                    label: b.label
                }));
                $('#interactive-results-controls').slideDown();
                showToast(`${suggestedBboxes.length} AI suggestions loaded for review.`, 3000);
            } else {
                // 仅当没有AI建议时才清理会话
                clearInteractiveSession(false);
                bboxes = manualBboxes;
            }

            if (interpolationState.isActive && currentFrameNum !== interpolationState.startFrameData.frame_number) {
                const existingBox = bboxes.find(b => b.id === interpolationState.objectId);
                if (!existingBox) {
                    const ghostBox = JSON.parse(JSON.stringify(interpolationState.startFrameData.bbox));
                    bboxes.push(ghostBox);
                    selectedBboxIndex = bboxes.length - 1;
                } else {
                    selectedBboxIndex = bboxes.findIndex(b => b.id === interpolationState.objectId);
                }
            } else if (!interpolationState.isActive) {
                selectedBboxIndex = -1;
            }

            history = [JSON.parse(JSON.stringify(bboxes))];
            historyIndex = 0;
            redrawCanvas();
            renderBboxList();
        }
        // <!-- FIX [问题一] END -->

        function addClass(className) {
            if (className && !availableClasses.includes(className)) {
                $.ajax({
                    url: "/addClass",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        label_name: className
                    }),
                    success: function() {
                        availableClasses.push(className);
                        renderClassList();
                    },
                    error: function() {
                        showToast("Error: Failed to add new class.", 3000);
                    }
                });
            }
        }

        function updateSamButtonText() {
            const button = $("#sam-toggle-btn");
            if (isSamModeActive) {
                const text = isInteractiveMode ? "SAM ON (for Sample)" : "SAM ON (for Annotation)";
                button.html(`<i class="bi bi-magic"></i> ${text}`);
            } else {
                button.html('<i class="bi bi-magic"></i> Enable SAM (Point)');
            }
        }

        function setTrackingUiState(isReview) {
            isReviewMode = isReview;
            $("#track-controls").slideToggle(isReview);
            $("#save-bboxes, #sam-toggle-btn, #sam2-track-btn, #interactive-mode-toggle, #lam-toggle-btn").slideToggle(!isReview);

            if (!isReview) {
                $("#track-progress-bar").css("width", "0%").text("0%").removeClass("bg-success bg-danger").addClass("progress-bar-animated");
                $("#track-status-header").text("Tracking...");
                $("#stop-sam2-track-btn").prop("disabled", false).text("Stop Tracking");
                $("#save-all-tracked-btn").prop("disabled", true);
                sam2TrackerUuid = null;
                if (sam2EventSource) {
                    sam2EventSource.close();
                    sam2EventSource = null;
                }
            }
        }

        function exitReviewMode() {
            setTrackingUiState(false);
            trackedBboxCache = {};
            showToast("Exited tracking/review mode.", 2000);
            frameSlider.trigger("input");
        }

        function handleSseEvent(eventData) {
            switch (eventData.event) {
                case "update":
                    trackedBboxCache[eventData.frame_number] = eventData.bboxes_text;
                    const percentage = eventData.total > 0 ? Math.round(eventData.progress / eventData.total * 100) : 0;
                    $("#track-progress-bar").css("width", percentage + "%").text(percentage + "%");

                    const frameNumber = eventData.frame_number;
                    if (frameNumber <= parseInt(frameSlider.attr("max"))) {
                        frameSlider.val(frameNumber);
                        $("#frame-number-display").text(frameNumber);
                        const imageUrl = `/media/frames/${videoUuid}/frame_${String(frameNumber).padStart(5, "0")}.jpg`;
                        if (!frameImage.src.endsWith(imageUrl)) {
                            frameImage.src = imageUrl;
                        }
                    }
                    break;
                case "batch_update":
                    const batch_percentage = eventData.total > 0 ? Math.round(eventData.progress / eventData.total * 100) : 0;
                     $("#track-progress-bar").css("width", batch_percentage + "%").text(batch_percentage + "%");
                     $("#track-status-header").text(eventData.message || `Batch Tracking...`);
                    break;
                case "completed":
                case "stopped":
                case "failed":
                    if(eventData.results) {
                        Object.assign(trackedBboxCache, eventData.results);
                    }
                    handleTrackingEnd(eventData.event.toUpperCase(), eventData.message);
                    break;

                case "error":
                    alert("Tracking Stream Error: " + eventData.message);
                    handleTrackingEnd("FAILED", eventData.message);
                    break;
            }
        }

        function handleTrackingEnd(status, message) {
            if (sam2EventSource) {
                sam2EventSource.close();
                sam2EventSource = null;
            }

            $("#sam2-track-btn").prop("disabled", false);
            $("#stop-sam2-track-btn").prop("disabled", true);
            const progressBar = $("#track-progress-bar");
            progressBar.removeClass("progress-bar-animated");

            let statusText = "Review Results";
            if (status === "COMPLETED") {
                statusText = "Tracking Completed. Review Results.";
                progressBar.css("width", "100%").text("100%").addClass("bg-success");
            } else if (status === "STOPPED") {
                statusText = "Tracking Stopped. Review Results.";
            } else if (status === "FAILED") {
                statusText = "Tracking Failed. Review Partial Results.";
                progressBar.addClass("bg-danger");
            }

            $("#track-status-header").text(statusText);
            $("#save-all-tracked-btn").prop("disabled", Object.keys(trackedBboxCache).length === 0);
            showToast(statusText + (message ? ` (${message})` : ""), 4000);

            const firstFrame = Math.min(...Object.keys(trackedBboxCache).map(Number));
            if (isFinite(firstFrame)) {
                frameSlider.val(firstFrame).trigger("input");
            }
        }

        function clearInteractiveSession(shouldRedraw = true) {
            positiveExampleBboxes = [];
            previewBboxes = [];
            lastDatasetClassName = null;
            hoveredPreviewIndex = -1;
            overlappingCycleIndex = 0;
            lastClickPosForCycle = null;
            $('#interactive-results-controls').slideUp();
            if (shouldRedraw) {
                redrawCanvas();
            }
        }

        function triggerFindSimilar() {
            if (positiveExampleBboxes.length === 0) {
                 showToast("Please provide one positive sample.", 2000);
                return;
            }
            lastDatasetClassName = null;
            const frameNumber = parseInt(frameSlider.val());
            const $button = $('#find-similar-btn');
            $button.prop('disabled', true);

            const runPrediction = () => {
                showToast('Finding similar objects...', 4000);
                const payload = {
                    video_uuid: videoUuid,
                    frame_number: frameNumber,
                    prompt_boxes: positiveExampleBboxes
                };
                $.ajax({
                    url: '/interactive_segment/predict',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify(payload),
                    success: res => {
                        if (res.success) {
                            previewBboxes = res.results;
                            $('#interactive-results-controls').slideDown();
                            $('#result-threshold').trigger('input');
                            redrawCanvas();
                        } else {
                            alert('Prediction failed: ' + res.message);
                        }
                    },
                    error: () => alert('Server error during prediction.'),
                    complete: () => $button.prop('disabled', false)
                });
            };

            if (lastProcessedFrame !== frameNumber) {
                showToast('Preprocessing frame for Smart Select...', 10000);
                const payload = { video_uuid: videoUuid, frame_number: frameNumber };
                $.ajax({
                    url: '/interactive_segment/preprocess',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify(payload),
                    success: res => {
                        if (res.success) {
                            currentCacheKey = res.cache_key;
                            lastProcessedFrame = frameNumber;
                            runPrediction();
                        } else {
                            alert('Preprocessing failed: ' + res.message);
                            $button.prop('disabled', false);
                        }
                    },
                    error: () => {
                        alert('Server error during preprocessing.');
                        $button.prop('disabled', false);
                    }
                });
            } else {
                runPrediction();
            }
        }

        function startNegativeSampling(count) {
            $.ajax({
                url: '/api/get_random_frames_for_neg_sampling',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ video_uuid: videoUuid, count: count }),
                success: function(res) {
                    if (res.success && res.frames.length > 0) {
                        negSamplingFrames = res.frames;
                        currentNegSampleIndex = 0;
                        negativeSamplesStore = {};
                        loadNegativeSampleFrame();
                        $('#negative-sampling-modal').modal({ backdrop: 'static', keyboard: false });
                    } else {
                        alert("Failed to fetch random frames: " + (res.message || "No frames returned."));
                    }
                },
                error: function() {
                    alert("Server error while fetching random frames.");
                }
            });
        }
        
        // <!-- FIX [问题三] START -->
        // 新建一个专用于调整负样本Canvas尺寸的函数
        function resizeNegCanvas() {
            // 确保图片已加载且模态框可见，这是解决问题的关键
            if (!negImage.complete || negImage.naturalWidth === 0 || !$('#negative-sampling-modal').is(':visible')) {
                return;
            }
            const dpr = window.devicePixelRatio || 1;
            const rect = negImage.getBoundingClientRect();
            negCanvas.style.width = `${rect.width}px`;
            negCanvas.style.height = `${rect.height}px`;
            negCanvas.width = Math.round(rect.width * dpr);
            negCanvas.height = Math.round(rect.height * dpr);
            // 使用 setTransform 代替 scale 来避免累积缩放，更稳健
            negCtx.setTransform(dpr, 0, 0, dpr, 0, 0); 
            redrawNegCanvas();
        }

        // 修改 loadNegativeSampleFrame 函数，移除尺寸设置逻辑
        function loadNegativeSampleFrame() {
            if (currentNegSampleIndex < 0 || currentNegSampleIndex >= negSamplingFrames.length) return;
            const frameData = negSamplingFrames[currentNegSampleIndex];
            $('#neg-frame-counter').text(`Frame ${currentNegSampleIndex + 1} / ${negSamplingFrames.length}`);
            
            negImage.onload = () => {
                // 图片加载后，调用新的resize函数，它会处理好一切
                resizeNegCanvas();
            };
            negImage.src = frameData.image_url;
        }
        // <!-- FIX [问题三] END -->


        function redrawNegCanvas() {
            const dpr = window.devicePixelRatio || 1;
            negCtx.clearRect(0, 0, negCanvas.width / dpr, negCanvas.height / dpr);
            if (negSamplingFrames.length === 0) return;
            const frameData = negSamplingFrames[currentNegSampleIndex];
            const frameKey = `${frameData.video_uuid};${frameData.frame_number}`;
            const boxes = negativeSamplesStore[frameKey] || [];
            if (!negImage.naturalWidth) return;
            const scaleX = negImage.clientWidth / negImage.naturalWidth;
            const scaleY = negImage.clientHeight / negImage.naturalHeight;
            boxes.forEach(box => {
                negCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                negCtx.lineWidth = 2 / dpr;
                negCtx.setLineDash([5 / dpr, 3 / dpr]);
                const x = box[0] * scaleX, y = box[1] * scaleY, w = (box[2] - box[0]) * scaleX, h = (box[3] - box[1]) * scaleY;
                negCtx.strokeRect(x, y, w, h);
                negCtx.setLineDash([]);
            });
        }

        function triggerApplyToVideo(negativeSamples) {
            if (!lastDatasetClassName) {
                alert("An error occurred. The class to apply is unknown.");
                return;
            }
            const confirmMessage = negativeSamples && Object.keys(negativeSamples).length > 0 ?
                `This will start a background task to apply the REFINED model for '${lastDatasetClassName}' to all unlabeled frames. Continue?` :
                `This will start a background task to apply the learned features for '${lastDatasetClassName}' to all unlabeled frames. Continue?`;

            if (confirm(confirmMessage)) {
                const payload = {
                    video_uuid: videoUuid,
                    class_name: lastDatasetClassName,
                    negative_samples: negativeSamples
                };
                $.ajax({
                    url: '/apply_prototypes_to_video',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify(payload),
                    success: function(res) {
                        if (res.success) {
                            alert("Task started successfully! You can now close this page. The video status will update on the main page.");
                            window.location.href = "/";
                        } else {
                            alert("Failed to start task: " + res.message);
                        }
                    },
                    error: function() {
                        alert("Server error when trying to start the task.");
                    }
                });
            }
        }

        function undoNegativeSample() {
            if (currentNegSampleIndex < 0 || currentNegSampleIndex >= negSamplingFrames.length) return;
            const frameData = negSamplingFrames[currentNegSampleIndex];
            const frameKey = `${frameData.video_uuid};${frameData.frame_number}`;
            if (negativeSamplesStore[frameKey] && negativeSamplesStore[frameKey].length > 0) {
                negativeSamplesStore[frameKey].pop();
                redrawNegCanvas();
                showToast('Last negative sample removed.', 1500);
            } else {
                showToast('Nothing to undo on this frame.', 1500);
            }
        }

        function clearCurrentNegativeSamples() {
            if (currentNegSampleIndex < 0 || currentNegSampleIndex >= negSamplingFrames.length) return;
            const frameData = negSamplingFrames[currentNegSampleIndex];
            const frameKey = `${frameData.video_uuid};${frameData.frame_number}`;
            if (negativeSamplesStore[frameKey] && negativeSamplesStore[frameKey].length > 0) {
                negativeSamplesStore[frameKey] = [];
                redrawNegCanvas();
                showToast('All negative samples cleared for this frame.', 1500);
            }
        }

        function resetInterpolationState(reloadFrame = false) {
            interpolationState = {
                isActive: false,
                objectId: null,
                startFrameData: null
            };
            $('#interpolation-banner').slideUp();
            if (reloadFrame) {
                frameSlider.trigger("input");
            } else {
                renderBboxList();
                redrawCanvas();
            }
        }

        function showLamSuggestions(bbox, suggestions, clickX, clickY) {
            const tempBbox = { ...bbox, label: 'suggestion', id: 'temp' };
            bboxes.push(tempBbox);
            redrawCanvas();
            bboxes.pop();

            const template = document.getElementById('lam-suggestion-popup-template').content.cloneNode(true);
            const popup = $(template).find('#lam-suggestion-popup');
            const suggestionList = popup.find('.list-group');

            if (suggestions.length === 0) {
                suggestionList.append('<div class="list-group-item">No suggestions, please label manually.</div>');
            } else {
                suggestions.forEach(sug => {
                    const color = stringToColor(sug.label);
                    const scorePercent = (sug.score * 100).toFixed(1);
                    const item = $(`
                        <button type="button" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center" data-label="${sug.label}">
                            <div>
                                <span class="color-swatch" style="background-color: ${color};"></span>
                                ${sug.label}
                            </div>
                            <span class="badge badge-primary badge-pill">${scorePercent}%</span>
                        </button>
                    `);
                    suggestionList.append(item);
                });
            }

            $('body').append(popup);
            popup.css({ top: `${clickY + 5}px`, left: `${clickX + 5}px` });

            popup.on('click', 'button', function() {
                const selectedLabel = $(this).data('label');
                if (selectedLabel) {
                    const newBox = {
                        ...bbox,
                        label: selectedLabel,
                        id: self.crypto.randomUUID()
                    };
                    bboxes.push(newBox);
                    saveStateToHistory();
                    selectedBboxIndex = bboxes.length - 1;
                    renderBboxList();
                }
                popup.remove();
                redrawCanvas();
            });

            setTimeout(() => {
                $(document).one('mousedown', function(e) {
                    if (!$(e.target).closest('#lam-suggestion-popup').length) {
                        popup.remove();
                        redrawCanvas();
                    }
                });
            }, 100);
        }

        // <!-- FIX [问题二] START -->
        // 修改 frameImage.onload 以恢复每帧的置信度设置
        frameImage.onload = function() {
            bboxes = [];
            selectedBboxIndex = -1;
            resizeCanvas();
            const frameNumber = frameSlider.val();
            loadBboxesForFrame(frameNumber);
            triggerBackgroundPreprocess(frameNumber);

            // 恢复此帧的置信度滑块值
            const defaultThreshold = 0.50; // 设置一个合理的默认值
            // 如果frameConfidence对象中有当前帧的记录，则使用它，否则使用默认值
            const currentFrameThreshold = frameConfidence[frameNumber] ?? defaultThreshold;
            $('#result-threshold').val(currentFrameThreshold);
            // 必须触发 'input' 事件来同步更新UI上的文本值并用新阈值重绘Canvas
            $('#result-threshold').trigger('input'); 
        };
        // <!-- FIX [问题二] END -->


        frameImage.addEventListener('dragstart', (e) => e.preventDefault());
        window.onresize = resizeCanvas;

        frameSlider.on("input", function() {
            const frameNumber = $(this).val();
            $("#frame-number-display").text(frameNumber);
            const imageUrl = `/media/frames/${videoUuid}/frame_${String(frameNumber).padStart(5, "0")}.jpg`;
            if (frameImage.src.endsWith(imageUrl) === false) {
                frameImage.src = imageUrl;
            } else if (frameImage.complete) {
                // 如果图片URL未变但需要重新加载数据 (例如，在review模式下)
                loadBboxesForFrame(frameNumber);
                triggerBackgroundPreprocess(frameNumber);
            }
        });

        canvasContainer.on('mousedown', function(e) {
            if (isLamModeActive) {
                e.preventDefault();
                $('#lam-suggestion-popup').remove();
                const pos = getMousePos(drawingCanvas, e);
                const scaleX = frameImage.naturalWidth / frameImage.clientWidth;
                const scaleY = frameImage.naturalHeight / frameImage.clientHeight;

                canvasContainer.addClass('sam-loading');
                showToast('LAM is thinking...', 5000);

                $.ajax({
                    url: "/lam_predict",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        video_uuid: videoUuid,
                        frame_number: frameSlider.val(),
                        point: {
                            x: Math.round(pos.x * scaleX),
                            y: Math.round(pos.y * scaleY)
                        }
                    }),
                    success: function(response) {
                        if (response.success) {
                            showLamSuggestions(response.bbox, response.suggestions, e.clientX, e.clientY);
                            showToast('Success! Please select a class.', 3000);
                        } else {
                            showToast(response.message || "LAM failed to identify an object.", 3000);
                        }
                    },
                    error: function(xhr) {
                        showToast('Server Error: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'Unknown Error'), 4000);
                    },
                    complete: function() {
                        canvasContainer.removeClass('sam-loading');
                    }
                });
                return;
            }

            if (isSamModeActive) {
                e.preventDefault();
                const pos = getMousePos(drawingCanvas, e);
                const scaleX = frameImage.naturalWidth / frameImage.clientWidth;
                const scaleY = frameImage.naturalHeight / frameImage.clientHeight;
                canvasContainer.addClass('sam-loading');
                showToast('SAM is thinking...', 5000);

                $.ajax({
                    url: "/samPredict",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        video_uuid: videoUuid,
                        frame_number: frameSlider.val(),
                        point: {
                            x: Math.round(pos.x * scaleX),
                            y: Math.round(pos.y * scaleY)
                        }
                    }),
                    success: function(response) {
                        if (!response.success) {
                            showToast(response.message || "SAM failed to find an object.", 3000);
                            return;
                        }

                        if (isInteractiveMode) {
                            positiveExampleBboxes = [response.bbox];
                            redrawCanvas();
                            showToast('Positive SAM sample added. Auto-finding similar objects...', 2000);
                            triggerFindSimilar();
                        } else {
                            if (activeClass) {
                                const newBox = { ...response.bbox,
                                    label: activeClass,
                                    id: self.crypto.randomUUID()
                                };
                                bboxes.push(newBox);
                                saveStateToHistory();
                                selectedBboxIndex = bboxes.length - 1;
                                renderBboxList();
                                redrawCanvas();
                                showToast('SAM found an object!', 2000);
                            } else {
                                showToast('Please select a class before using SAM.', 3000);
                            }
                        }
                    },
                    error: function(xhr) {
                        const errorMsg = xhr.responseJSON ? xhr.responseJSON.message : 'Unknown error';
                        showToast('Server error during SAM prediction: ' + errorMsg, 4000);
                    },
                    complete: function() {
                        canvasContainer.removeClass('sam-loading');
                    }
                });
                return;
            }

            if (isReviewMode) return;
            const pos = getMousePos(drawingCanvas, e);

            if ((isInteractiveMode || previewBboxes.length > 0) && previewBboxes.length > 0) {
                if (!activeClass) {
                    alert("Please select a class from the list to assign it.");
                    return;
                }
                const threshold = parseFloat($('#result-threshold').val());
                const scaleX = frameImage.clientWidth / frameImage.naturalWidth;
                const scaleY = frameImage.clientHeight / frameImage.naturalHeight;
                let targetBoxIndex = -1;

                const overlappingIndices = [];
                previewBboxes.forEach((res, index) => {
                    if (res.score >= threshold) {
                        const b = res.box;
                        if (pos.x > b[0] * scaleX && pos.x < b[2] * scaleX && pos.y > b[1] * scaleY && pos.y < b[3] * scaleY) {
                            overlappingIndices.unshift(index);
                        }
                    }
                });

                if (overlappingIndices.length > 0) {
                    e.preventDefault();
                    if (isCKeyPressed) {
                        const isSameClick = lastClickPosForCycle && Math.abs(lastClickPosForCycle.x - pos.x) < 5 && Math.abs(lastClickPosForCycle.y - pos.y) < 5;
                        overlappingCycleIndex = isSameClick ? (overlappingCycleIndex + 1) % overlappingIndices.length : 0;
                        targetBoxIndex = overlappingIndices[overlappingCycleIndex];
                        lastClickPosForCycle = pos;
                    } else {
                        targetBoxIndex = overlappingIndices[0];
                        lastClickPosForCycle = null;
                    }

                    const res = previewBboxes[targetBoxIndex];
                    const b = res.box;
                    bboxes.push({
                        x1: b[0],
                        y1: b[1],
                        x2: b[2],
                        y2: b[3],
                        label: res.label || activeClass
                    });
                    previewBboxes.splice(targetBoxIndex, 1);
                    saveStateToHistory();
                    renderBboxList();
                    hoveredPreviewIndex = -1;
                    redrawCanvas();
                    return;
                }
            }

            if (isInteractiveMode) {
                isDrawing = true;
                startX = pos.x;
                startY = pos.y;
                clearCrosshairs();
                return;
            }

            draggedHandle = getHandleAtPos(pos.x, pos.y);
            if (draggedHandle) {
                isDraggingBbox = true;
                editMode = 'resize';
                draggedBboxInitialState = JSON.parse(JSON.stringify(bboxes[selectedBboxIndex]));
                return;
            }

            const scaleX = frameImage.clientWidth / frameImage.naturalWidth;
            const scaleY = frameImage.clientHeight / frameImage.naturalHeight;
            let clickedOnBoxIndex = -1;
            for (let i = bboxes.length - 1; i >= 0; i--) {
                const box = bboxes[i];
                const bx = box.x1 * scaleX,
                    by = box.y1 * scaleY,
                    bw = (box.x2 - box.x1) * scaleX,
                    bh = (box.y2 - box.y1) * scaleY;
                if (pos.x > bx && pos.x < bx + bw && pos.y > by && pos.y < by + bh) {
                    clickedOnBoxIndex = i;
                    break;
                }
            }

            if (clickedOnBoxIndex !== -1) {
                selectedBboxIndex = clickedOnBoxIndex;
                isDraggingBbox = true;
                editMode = 'move';
                draggedBboxInitialState = JSON.parse(JSON.stringify(bboxes[selectedBboxIndex]));
                startX = pos.x;
                startY = pos.y;
                renderBboxList();
                redrawCanvas();
            } else {
                selectedBboxIndex = -1;
                renderBboxList();
                redrawCanvas();
                if (activeClass) {
                    isDrawing = true;
                    startX = pos.x;
                    startY = pos.y;
                    clearCrosshairs();
                }
            }
        });

        $(document).on('mousemove', function(e) {
            if (!$(e.target).closest('#canvas-container').length) {
                if (hoveredPreviewIndex !== -1) {
                    hoveredPreviewIndex = -1;
                    redrawCanvas();
                }
                $(drawingCanvas).removeClass((index, className) => (className.match(/\bcursor-\S+/g) || []).join(' '));
                return;
            }

            const pos = getMousePos(drawingCanvas, e);

            if (isDrawing) {
                redrawCanvas();
                const dpr = window.devicePixelRatio || 1;
                let currentX = Math.max(0, Math.min(pos.x, frameImage.clientWidth));
                let currentY = Math.max(0, Math.min(pos.y, frameImage.clientHeight));
                drawingCtx.lineWidth = 2 / dpr;
                drawingCtx.strokeStyle = isInteractiveMode ? 'rgba(40,167,69,0.9)' : stringToColor(activeClass || 'blue');
                drawingCtx.setLineDash(isInteractiveMode ? [5 / dpr, 3 / dpr] : []);
                drawingCtx.strokeRect(startX, startY, currentX - startX, currentY - startY);
                drawingCtx.setLineDash([]);

            } else if (isDraggingBbox) {
                const scaleX = frameImage.naturalWidth / frameImage.clientWidth;
                const scaleY = frameImage.naturalHeight / frameImage.clientHeight;
                let currentBox = bboxes[selectedBboxIndex];

                if (editMode === 'move') {
                    const dx = (pos.x - startX) * scaleX;
                    const dy = (pos.y - startY) * scaleY;
                    currentBox.x1 = draggedBboxInitialState.x1 + dx;
                    currentBox.y1 = draggedBboxInitialState.y1 + dy;
                    currentBox.x2 = draggedBboxInitialState.x2 + dx;
                    currentBox.y2 = draggedBboxInitialState.y2 + dy;
                } else if (editMode === 'resize') {
                    const newX = pos.x * scaleX;
                    const newY = pos.y * scaleY;
                    const initialState = draggedBboxInitialState;
                    if (draggedHandle.includes('left')) currentBox.x1 = Math.min(newX, initialState.x2 - 1);
                    if (draggedHandle.includes('right')) currentBox.x2 = Math.max(newX, initialState.x1 + 1);
                    if (draggedHandle.includes('top')) currentBox.y1 = Math.min(newY, initialState.y2 - 1);
                    if (draggedHandle.includes('bottom')) currentBox.y2 = Math.max(newY, initialState.y1 + 1);
                }
                redrawCanvas();

            } else {
                drawCrosshairs(pos.x, pos.y);
                const handle = getHandleAtPos(pos.x, pos.y);
                $(drawingCanvas).removeClass((index, className) => (className.match(/\bcursor-\S+/g) || []).join(' '));
                if (handle) {
                    if (handle.includes('top-left') || handle.includes('bottom-right')) $(drawingCanvas).addClass('cursor-nwse-resize');
                    else if (handle.includes('top-right') || handle.includes('bottom-left')) $(drawingCanvas).addClass('cursor-nesw-resize');
                    else if (handle.includes('top') || handle.includes('bottom')) $(drawingCanvas).addClass('cursor-ns-resize');
                    else if (handle.includes('left') || handle.includes('right')) $(drawingCanvas).addClass('cursor-ew-resize');
                } else {
                    const scaleX = frameImage.clientWidth / frameImage.naturalWidth;
                    const scaleY = frameImage.clientHeight / frameImage.naturalHeight;
                    let onBox = false;
                    for (let i = 0; i < bboxes.length; i++) {
                        const box = bboxes[i];
                        if (pos.x > box.x1 * scaleX && pos.x < box.x2 * scaleX && pos.y > box.y1 * scaleY && pos.y < box.y2 * scaleY) {
                            onBox = true;
                            break;
                        }
                    }
                    if (onBox) $(drawingCanvas).addClass('cursor-move');
                }

                if ((isInteractiveMode || previewBboxes.length > 0) && previewBboxes.length > 0) {
                    const scaleX = frameImage.clientWidth / frameImage.naturalWidth;
                    const scaleY = frameImage.clientHeight / frameImage.naturalHeight;
                    const threshold = parseFloat($('#result-threshold').val());
                    let foundIndex = -1;
                    for (let i = previewBboxes.length - 1; i >= 0; i--) {
                        const res = previewBboxes[i];
                        if (res.score >= threshold) {
                            const b = res.box;
                            if (pos.x > b[0] * scaleX && pos.x < b[2] * scaleX && pos.y > b[1] * scaleY && pos.y < b[3] * scaleY) {
                                foundIndex = i;
                                break;
                            }
                        }
                    }
                    if (foundIndex !== hoveredPreviewIndex) {
                        hoveredPreviewIndex = foundIndex;
                        redrawCanvas();
                    }
                }
            }
        }).on('mouseup', function(e) {
            if (isDrawing) {
                isDrawing = false;
                const pos = getMousePos(drawingCanvas, e);
                let endX = Math.max(0, Math.min(pos.x, frameImage.clientWidth));
                let endY = Math.max(0, Math.min(pos.y, frameImage.clientHeight));

                if (Math.abs(startX - endX) < 5 || Math.abs(startY - endY) < 5) {
                    redrawCanvas();
                    return;
                }

                const scaleX = frameImage.naturalWidth / frameImage.clientWidth;
                const scaleY = frameImage.naturalHeight / frameImage.clientHeight;
                const newBoxRaw = {
                    x1: Math.round(Math.min(startX, endX) * scaleX),
                    y1: Math.round(Math.min(startY, endY) * scaleY),
                    x2: Math.round(Math.max(startX, endX) * scaleX),
                    y2: Math.round(Math.max(startY, endY) * scaleY)
                };

                if (isInteractiveMode) {
                    positiveExampleBboxes = [newBoxRaw];
                    redrawCanvas();
                    triggerFindSimilar();
                } else if (activeClass) {
                    const newBox = { ...newBoxRaw,
                        label: activeClass,
                        id: self.crypto.randomUUID()
                    };
                    bboxes.push(newBox);
                    saveStateToHistory();
                    selectedBboxIndex = bboxes.length - 1;
                    renderBboxList();
                }
                redrawCanvas();

            } else if (isDraggingBbox) {
                let finalBox = bboxes[selectedBboxIndex];
                finalBox.x1 = Math.round(finalBox.x1);
                finalBox.y1 = Math.round(finalBox.y1);
                finalBox.x2 = Math.round(finalBox.x2);
                finalBox.y2 = Math.round(finalBox.y2);

                if (finalBox.x1 > finalBox.x2) [finalBox.x1, finalBox.x2] = [finalBox.x2, finalBox.x1];
                if (finalBox.y1 > finalBox.y2) [finalBox.y1, finalBox.y2] = [finalBox.y2, finalBox.y1];

                saveStateToHistory();
                isDraggingBbox = false;
                editMode = null;
                draggedHandle = null;
                draggedBboxInitialState = null;
                redrawCanvas();
            }
        });

        $('#canvas-container').on('mouseleave', function() {
            clearCrosshairs();
            $(drawingCanvas).removeClass((index, className) => (className.match(/\bcursor-\S+/g) || []).join(' '));
        });

        $('#add-class-btn').on('click', function() {
            const className = $('#new-class-name').val().trim();
            if (className) {
                addClass(className);
                $('#new-class-name').val('');
            }
        });

        $('#new-class-name').on("keydown", function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                $('#add-class-btn').click();
            }
        });

        $("#class-list").on("click", ".list-group-item", function() {
            const clickedClass = $(this).data("class-name");
            activeClass = activeClass === clickedClass ? null : clickedClass;
            renderClassList();
        });

        $('#bbox-list').on("click", ".list-group-item", function() {
            selectedBboxIndex = parseInt($(this).data("index"));
            redrawCanvas();
            renderBboxList();
        });

        $("#bbox-list").on("click", ".delete-bbox-btn", function(e) {
            e.stopPropagation();
            const index = parseInt($(this).data("index"));
            bboxes.splice(index, 1);
            saveStateToHistory();
            selectedBboxIndex = -1;
            redrawCanvas();
            renderBboxList();
        });

        $("#save-bboxes").on("click", function() {
            const frameNumber = frameSlider.val();
            if (isReviewMode) {
                trackedBboxCache[frameNumber] = formatBboxesToString();
                showToast(`Frame ${frameNumber} updated in review cache.`, 1500);
            } else {
                $.ajax({
                    url: "/storeVideoFrameBboxesText",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        video_uuid: videoUuid,
                        frame_number: frameNumber,
                        bboxes_text: formatBboxesToString()
                    }),
                    success: function(response) {
                        if (response.success) {
                            showToast("Frame " + frameSlider.val() + " saved successfully!");
                            window.cachedFrames = null;
                        }
                    },
                    error: function() {
                        showToast("Error: Failed to save bounding boxes.", 3000);
                    }
                });
            }
        });

        $('#rebuild-prototypes-btn').on('click', function() {
            if (confirm('This will start a background task to update the AI prototypes for all classes based on the latest labels. This may take a moment. Continue?')) {
                const $btn = $(this);
                $btn.prop('disabled', true).html('<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Rebuilding...');

                $.ajax({
                    url: '/api/rebuild_prototypes',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({}),
                    success: function(res) {
                        if(res.success) {
                            showToast(res.message, 4000);
                        } else {
                            showToast('Error: ' + res.message, 5000);
                        }
                    },
                    error: function() {
                        showToast('Error: Failed to start prototype rebuild task.', 5000);
                    },
                    complete: function() {
                        setTimeout(() => {
                            $btn.prop('disabled', false).html('<i class="bi bi-arrow-clockwise"></i> Rebuild AI Models');
                        }, 2000);
                    }
                });
            }
        });

        $('#lam-toggle-btn').on('click', function() {
            isLamModeActive = !isLamModeActive;
            $(this).toggleClass('active', isLamModeActive);
            canvasContainer.toggleClass('lam-active', isLamModeActive);

            if (isLamModeActive) {
                $(this).html('<i class="bi bi-bullseye"></i> LAM Mode ON');
                if (isSamModeActive) $('#sam-toggle-btn').click();
                if (isInteractiveMode) $('#interactive-mode-toggle').click();
                showToast('LAM Mode Activated: Click an object to get class suggestions.', 3000);
            } else {
                $(this).html('<i class="bi bi-bullseye"></i> Enable LAM (Click to Label)');
                $('#lam-suggestion-popup').remove();
            }
        });

        $('#sam-toggle-btn').on('click', function() {
            isSamModeActive = !isSamModeActive;
            $(this).toggleClass('active', isSamModeActive);
            canvasContainer.toggleClass('sam-active', isSamModeActive);
            updateSamButtonText();
            if (isSamModeActive) {
                if(isLamModeActive) $('#lam-toggle-btn').click();
                clearCrosshairs();
            }
        });

        $('#sam2-track-btn').on('click', function() {
            if (bboxes.length === 0) {
                alert("Please label at least one object on the current frame to start tracking.");
                return;
            }
            const startFrame = parseInt(frameSlider.val());
            const maxFrame = parseInt(frameSlider.attr("max"));
            $('#batch-end-frame').val(maxFrame).attr('min', startFrame + 1).attr('max', maxFrame);
            $('#tracking-options-modal').modal('show');
        });

        $('input[name="tracking-mode"]').on('change', function() {
            $('#batch-mode-options').toggle($(this).val() === 'batch');
        });

        $('#confirm-tracking-start').on('click', function() {
            const mode = $('input[name="tracking-mode"]:checked').val();
            const startFrame = parseInt(frameSlider.val());
            const initBboxesText = formatBboxesToString();

            $('#tracking-options-modal').modal('hide');
            $(this).prop("disabled", true);
            setTrackingUiState(true);
            trackedBboxCache = {};
            trackedBboxCache[startFrame] = initBboxesText;

            if (mode === 'interactive') {
                const endFrame = parseInt(frameSlider.attr("max"));
                startInteractiveTracking(startFrame, endFrame, initBboxesText);
            } else {
                const endFrameBatch = parseInt($('#batch-end-frame').val());
                if (endFrameBatch <= startFrame) {
                    alert("End frame must be after the start frame.");
                    exitReviewMode();
                    return;
                }
                $("#track-status-header").text("Batch Tracking Initializing...");
                startBatchTracking(startFrame, endFrameBatch, initBboxesText);
            }
        });

        function startInteractiveTracking(startFrame, endFrame, initBboxesText) {
             $.ajax({
                url: "/startSam2Tracking",
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({
                    video_uuid: videoUuid,
                    start_frame: startFrame,
                    end_frame: endFrame,
                    init_bboxes_text: initBboxesText
                }),
                success: (res) => {
                    if (res.success) {
                        sam2TrackerUuid = res.tracker_uuid;
                        sam2EventSource = new EventSource(`/streamSam2Tracking/${sam2TrackerUuid}`);
                        sam2EventSource.onmessage = function(event) {
                            const data = JSON.parse(event.data);
                            handleSseEvent(data);
                        };
                        sam2EventSource.onerror = function(err) {
                            showToast("Connection to tracking stream lost.", 3000);
                            handleTrackingEnd("FAILED", "Connection lost");
                            if (sam2EventSource) sam2EventSource.close();
                        };
                    } else {
                        alert("Error starting interactive tracking: " + res.message);
                        exitReviewMode();
                    }
                },
                error: () => {
                    alert("Server error starting interactive tracking.");
                    exitReviewMode();
                }
            });
        }
        function triggerBackgroundPreprocess(frameNumber) {
            $.ajax({
                url: "/api/background_preprocess_frame",
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({
                    video_uuid: videoUuid,
                    frame_number: parseInt(frameNumber)
                }),
            });
        }
        function startBatchTracking(startFrame, endFrame, initBboxesText) {
             $.ajax({
                url: "/startSam2BatchTracking",
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({
                    video_uuid: videoUuid,
                    start_frame: startFrame,
                    end_frame: endFrame,
                    init_bboxes_text: initBboxesText
                }),
                success: (res) => {
                    if (res.success) {
                        sam2TrackerUuid = res.tracker_uuid;
                        sam2EventSource = new EventSource(`/streamSam2Tracking/${sam2TrackerUuid}`);
                        sam2EventSource.onmessage = function(event) {
                            const data = JSON.parse(event.data);
                            handleSseEvent(data);
                        };
                         sam2EventSource.onerror = function(err) {
                            showToast("Connection to tracking stream lost.", 3000);
                            handleTrackingEnd("FAILED", "Connection lost");
                            if (sam2EventSource) sam2EventSource.close();
                        };
                    } else {
                        alert("Error starting batch tracking: " + res.message);
                        exitReviewMode();
                    }
                },
                error: () => {
                    alert("Server error starting batch tracking.");
                    exitReviewMode();
                }
            });
        }

        $('#stop-sam2-track-btn').on('click', function() {
            if (sam2TrackerUuid) {
                $(this).prop("disabled", true).text("Stopping...");
                $.ajax({
                    url: "/stopSam2Tracking",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        tracker_uuid: sam2TrackerUuid
                    })
                });
            }
        });

        $('#exit-track-mode-btn').on('click', exitReviewMode);

        $('#save-all-tracked-btn').on('click', function() {
            const frameCount = Object.keys(trackedBboxCache).length;
            if (confirm(`This will save all ${frameCount} reviewed annotations to the database. Are you sure?`)) {
                const savePromises = Object.entries(trackedBboxCache).map(([frame_number, bboxes_text]) =>
                    $.ajax({
                        url: "/storeVideoFrameBboxesText",
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify({
                            video_uuid: videoUuid,
                            frame_number: parseInt(frame_number),
                            bboxes_text: bboxes_text
                        })
                    })
                );
                showToast(`Saving ${savePromises.length} frames...`, 5000);
                Promise.all(savePromises).then(() => {
                    showToast("All tracked frames saved successfully!", 3000);
                    window.cachedFrames = null;
                    exitReviewMode();
                }).catch(err => {
                    alert("An error occurred while saving some frames.");
                });
            }
        });

        $('#bbox-list').on('click', '.interpolate-btn', function(e) {
            e.stopPropagation();
            const boxIndex = parseInt($(this).closest('li').data('index'));
            const clickedBox = bboxes[boxIndex];
            const currentFrame = parseInt(frameSlider.val());

            if (!clickedBox.id) {
                showToast("Error: This object has no ID. Please save first.", 3000);
                return;
            }

            if (!interpolationState.isActive) {
                interpolationState.isActive = true;
                interpolationState.objectId = clickedBox.id;
                interpolationState.startFrameData = {
                    frame_number: currentFrame,
                    bbox: JSON.parse(JSON.stringify(clickedBox))
                };
                $('#interpolation-banner').slideDown();
                showToast(`Keyframe 1 set for object ${clickedBox.id.substring(0,4)}. Go to another frame, adjust the box, and click the green 'Confirm' button.`, 5000);
            } else if (interpolationState.objectId === clickedBox.id) {
                if (currentFrame === interpolationState.startFrameData.frame_number) {
                    showToast("You are on the same frame. Move to a different frame to set the second keyframe.", 3000);
                    return;
                }
                const endFrameData = {
                    frame_number: currentFrame,
                    bbox: JSON.parse(JSON.stringify(clickedBox))
                };
                const $btn = $(this);
                $btn.prop('disabled', true).html('<span class="spinner-border spinner-border-sm"></span>');

                $.ajax({
                    url: "/api/interpolateBboxes",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        video_uuid: videoUuid,
                        object_id: interpolationState.objectId,
                        start_frame: interpolationState.startFrameData,
                        end_frame: endFrameData
                    }),
                    success: function(response) {
                        if (response.success) {
                            showToast(response.message, 4000);
                            window.cachedFrames = null;
                        } else {
                            showToast("Error: " + response.message, 5000);
                        }
                    },
                    error: function() {
                        showToast("Server error during interpolation.", 5000);
                    },
                    complete: function() {
                        const nextFrame = Math.min(parseInt(interpolationState.startFrameData.frame_number), parseInt(endFrameData.frame_number)) + 1;
                        resetInterpolationState(false);
                        if (nextFrame < frameCount && nextFrame > 0) {
                            frameSlider.val(nextFrame).trigger("input");
                        } else {
                            frameSlider.trigger("input");
                        }
                    }
                });
            }
            renderBboxList();
            redrawCanvas();
        });

        $('#interactive-mode-toggle').on('click', function() {
            isInteractiveMode = !isInteractiveMode;
            $(this).toggleClass('active', isInteractiveMode);
            $('#interactive-segment-controls').slideToggle(isInteractiveMode);
            if (isInteractiveMode) {
                $(this).html('<i class="bi bi-stars"></i> Smart Select ON');
                if(isLamModeActive) $('#lam-toggle-btn').click();
                clearCrosshairs();
            } else {
                $(this).html('<i class="bi bi-stars"></i> Enable Smart Select');
                clearInteractiveSession();
            }
            updateSamButtonText();
        });

        $('#clear-samples-btn').on('click', function() {
            clearInteractiveSession();
            showToast('Sample box and previews cleared.', 2000);
        });

        $('#find-from-dataset-btn').on('click', function() {
            if (!activeClass) {
                alert('Please select a class first!');
                return;
            }
            const frameNumber = parseInt(frameSlider.val());
            const $button = $(this);
            $button.prop('disabled', true);
            showToast(`Learning from all '${activeClass}' examples in the dataset...`, 10000);
            const payload = { video_uuid: videoUuid, frame_number: frameNumber, class_name: activeClass };
            $.ajax({
                url: '/interactive_segment/predict_from_dataset',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(payload),
                success: function(res) {
                    if (res.success) {
                        previewBboxes = res.results;
                        lastDatasetClassName = activeClass;
                        $('#interactive-results-controls').slideDown();
                        $('#result-threshold').trigger('input');
                        redrawCanvas();
                        showToast(`Found ${res.results.length} potential '${activeClass}' objects.`, 4000);
                        setTimeout(() => {
                           if (confirm(`Find from Dataset for '${activeClass}' successful.\n\nDo you want to refine the model by adding negative samples (e.g., background)? This can improve accuracy.`)) {
                                const frameCountStr = prompt("How many random frames would you like to label for negative samples?", "10");
                                const frameCount = frameCountStr ? parseInt(frameCountStr) : 0;
                                if (frameCount && !isNaN(frameCount) && frameCount > 0) {
                                    startNegativeSampling(frameCount);
                                } else {
                                     triggerApplyToVideo(null);
                                }
                            } else {
                                triggerApplyToVideo(null);
                            }
                        }, 500);
                    } else {
                        alert('Dataset-driven prediction failed: ' + res.message);
                    }
                },
                error: function() { alert('Server error during dataset-driven prediction.'); },
                complete: function() { $button.prop('disabled', false); }
            });
        });

        $('#neg-canvas-container').on('mousedown', function(e) {
            isDrawingNeg = true;
            const pos = getMousePos(negCanvas, e);
            negStartX = pos.x;
            negStartY = pos.y;
        }).on('mousemove', function(e) {
            if (!isDrawingNeg) return;
            redrawNegCanvas();
            const pos = getMousePos(negCanvas, e);
            const dpr = window.devicePixelRatio || 1;
            negCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            negCtx.lineWidth = 2 / dpr;
            negCtx.setLineDash([5 / dpr, 3 / dpr]);
            negCtx.strokeRect(negStartX, negStartY, pos.x - negStartX, pos.y - negStartY);
            negCtx.setLineDash([]);
        }).on('mouseup', function(e) {
            if (!isDrawingNeg) return;
            isDrawingNeg = false;
            const pos = getMousePos(negCanvas, e);
            const scaleX = negImage.naturalWidth / negImage.clientWidth;
            const scaleY = negImage.naturalHeight / negImage.clientHeight;
            const x1 = Math.round(Math.min(negStartX, pos.x) * scaleX);
            const y1 = Math.round(Math.min(negStartY, pos.y) * scaleY);
            const x2 = Math.round(Math.max(negStartX, pos.x) * scaleX);
            const y2 = Math.round(Math.max(negStartY, pos.y) * scaleY);

            if (Math.abs(x1 - x2) < 5 || Math.abs(y1 - y2) < 5) {
                redrawNegCanvas();
                return;
            }
            const frameData = negSamplingFrames[currentNegSampleIndex];
            const frameKey = `${frameData.video_uuid};${frameData.frame_number}`;
            if (!negativeSamplesStore[frameKey]) {
                negativeSamplesStore[frameKey] = [];
            }
            negativeSamplesStore[frameKey].push([x1, y1, x2, y2]);
            redrawNegCanvas();
        });

        $('#neg-prev-btn').on('click', function() { if (currentNegSampleIndex > 0) { currentNegSampleIndex--; loadNegativeSampleFrame(); } });
        $('#neg-next-btn').on('click', function() { if (currentNegSampleIndex < negSamplingFrames.length - 1) { currentNegSampleIndex++; loadNegativeSampleFrame(); } });
        $('#finish-neg-sampling-btn').on('click', function() {
            $('#negative-sampling-modal').modal('hide');
            const finalNegativeSamples = Object.fromEntries(
                Object.entries(negativeSamplesStore).filter(([key, value]) => value.length > 0)
            );
            if (Object.keys(finalNegativeSamples).length > 0) {
                showToast(`Refining model with ${Object.keys(finalNegativeSamples).length} frames of negative samples.`);
            } else {
                showToast("No negative samples were added. Applying original model.");
            }
            triggerApplyToVideo(finalNegativeSamples);
        });

        // <!-- FIX [问题二] START -->
        // 修改置信度滑块的事件，使其能将设置存入 per-frame 对象中
        $('#result-threshold').on('input', function() {
            const value = parseFloat($(this).val());
            $('#threshold-value').text(value.toFixed(2));
            
            // 将当前帧的置信度值存起来
            const currentFrame = frameSlider.val();
            frameConfidence[currentFrame] = value;
            
            redrawCanvas();
        });
        // <!-- FIX [问题二] END -->


        $('#accept-visible-btn').on('click', function() {
            if (!activeClass) {
                alert('Please select a class before accepting results.');
                return
            }
            const threshold = parseFloat($('#result-threshold').val());
            let addedCount = 0;
            const remainingPreviews = [];
            previewBboxes.forEach(res => {
                if (res.score >= threshold) {
                    const b = res.box;
                    bboxes.push({
                        x1: b[0],
                        y1: b[1],
                        x2: b[2],
                        y2: b[3],
                        label: res.label || activeClass
                    });
                    addedCount++;
                } else {
                    remainingPreviews.push(res);
                }
            });
            if (addedCount > 0) {
                previewBboxes = remainingPreviews;
                saveStateToHistory();
                renderBboxList();
                redrawCanvas();
                showToast(`${addedCount} new bounding boxes added.`, 2000);
            } else {
                showToast('No boxes above the current threshold to accept.', 2000);
            }
        });

        $('#finish-interactive-btn').on('click', clearInteractiveSession);

        $(document).on("keydown", function(e) {
            if ($(e.target).is("input, textarea")) return;

            const isNegModalVisible = $('#negative-sampling-modal').is(':visible');
            const key = e.key.toLowerCase();

            if (key === 'c') {
                e.preventDefault();
                isCKeyPressed = true;
            }

            if (e.ctrlKey && key === "z") {
                e.preventDefault();
                if (isNegModalVisible) {
                    undoNegativeSample();
                } else {
                    undo();
                }
            } else if (e.ctrlKey && (key === "y" || (e.shiftKey && key === "z"))) {
                if (!isNegModalVisible) {
                    e.preventDefault();
                    redo();
                }
            } else if (e.key === "Delete" || e.key === "Backspace") {
                e.preventDefault();
                if (isNegModalVisible) {
                    clearCurrentNegativeSamples();
                } else if (selectedBboxIndex !== -1) {
                    bboxes.splice(selectedBboxIndex, 1);
                    saveStateToHistory();
                    selectedBboxIndex = -1;
                    redrawCanvas();
                    renderBboxList();
                }
            } else if (e.key === "Escape" && interpolationState.isActive) {
                e.preventDefault();
                resetInterpolationState(true);
                showToast("Interpolation cancelled.", 2000);
            } else {
                switch (key) {
                    case "s":
                        if (!isNegModalVisible) {
                            e.preventDefault();
                            $("#save-bboxes").click();
                        }
                        break;
                    case "a":
                        e.preventDefault();
                        if (isNegModalVisible) {
                            $('#neg-prev-btn').click();
                        } else {
                            let prevFrame = parseInt(frameSlider.val()) - 1;
                            if (prevFrame >= task.start_frame) {
                                frameSlider.val(prevFrame).trigger("input");
                            }
                        }
                        break;
                    case "d":
                        e.preventDefault();
                        if (isNegModalVisible) {
                            $('#neg-next-btn').click();
                        } else {
                            let nextFrame = parseInt(frameSlider.val()) + 1;
                            if (nextFrame < frameCount) {
                                frameSlider.val(nextFrame).trigger("input");
                            }
                        }
                        break;
                }
            }
        }).on("keyup", function(e) {
            if (e.key.toLowerCase() === 'c') {
                isCKeyPressed = false;
            }
        });

        function performInitialLoad() {
            $.get('/listClasses', function(response) {
                if (response.success) {
                    response.labels.forEach(label => {
                        if (!availableClasses.includes(label)) {
                            availableClasses.push(label);
                        }
                    });
                    renderClassList();

                    const urlParams = new URLSearchParams(window.location.search);
                    const frameFromUrl = urlParams.get('frame');
                    if (frameFromUrl) {
                        const frameNumber = parseInt(frameFromUrl);
                        if (frameNumber >= parseInt(frameSlider.attr('min')) && frameNumber <= parseInt(frameSlider.attr('max'))) {
                            frameSlider.val(frameNumber);
                        }
                    }
                    resizeCanvas();
                    frameSlider.trigger('input');
                }
            });
        }
        
        // <!-- FIX [问题三] START -->
        // 为负样本模态框添加 shown.bs.modal 事件监听器，确保在模态框完全显示后再调整Canvas大小
        $('#negative-sampling-modal').on('shown.bs.modal', function () {
            resizeNegCanvas();
        });
        
        // 同时监听窗口大小变化，以防用户在模态框打开时调整浏览器窗口
        $(window).on('resize', function() {
            if ($('#negative-sampling-modal').is(':visible')) {
                resizeNegCanvas();
            }
        });
        // <!-- FIX [问题三] END -->

        if (window.cachedFrames) {
            delete window.cachedFrames;
        }

        if (frameImage.complete && frameImage.naturalWidth > 0) {
            performInitialLoad();
        } else {
            $(frameImage).one('load', performInitialLoad);
        }
    });
</script>
{% endblock %}